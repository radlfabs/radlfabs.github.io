<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Fabian Rosenthal">
<meta name="dcterms.date" content="2024-10-01">

<title>Uncertainty quantification for cross-validation (Master Thesis Write-up) – Fabian Rosenthal</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Fabian Rosenthal</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resume.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:rosenthalfabian@gmail.com"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/radlfabs"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/fabian-rosenthal-mle"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Uncertainty quantification for cross-validation (Master Thesis Write-up)</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">statistics</div>
                <div class="quarto-category">cross-validation</div>
                <div class="quarto-category">ML</div>
                <div class="quarto-category">R</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Fabian Rosenthal </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 1, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#research-questions" id="toc-research-questions" class="nav-link" data-scroll-target="#research-questions">Research Questions</a></li>
  </ul></li>
  <li><a href="#theoretical-background" id="toc-theoretical-background" class="nav-link" data-scroll-target="#theoretical-background">Theoretical Background</a>
  <ul class="collapse">
  <li><a href="#k-fold-cv" id="toc-k-fold-cv" class="nav-link" data-scroll-target="#k-fold-cv"><span class="math inline">\(k\)</span>-fold CV</a></li>
  <li><a href="#properties" id="toc-properties" class="nav-link" data-scroll-target="#properties">Properties</a></li>
  </ul></li>
  <li><a href="#methods-ademp" id="toc-methods-ademp" class="nav-link" data-scroll-target="#methods-ademp">Methods: ADEMP</a>
  <ul class="collapse">
  <li><a href="#what-are-we-doing" id="toc-what-are-we-doing" class="nav-link" data-scroll-target="#what-are-we-doing">What are we doing?</a></li>
  <li><a href="#a-for-aims" id="toc-a-for-aims" class="nav-link" data-scroll-target="#a-for-aims"><strong>A</strong> for <strong>AIMS</strong></a></li>
  <li><a href="#d-for-data-generating-process" id="toc-d-for-data-generating-process" class="nav-link" data-scroll-target="#d-for-data-generating-process"><strong>D</strong> for <strong>Data Generating Process</strong></a></li>
  <li><a href="#e-for-estimand" id="toc-e-for-estimand" class="nav-link" data-scroll-target="#e-for-estimand"><strong>E</strong> for <strong>Estimand</strong></a></li>
  <li><a href="#m-for-methods" id="toc-m-for-methods" class="nav-link" data-scroll-target="#m-for-methods"><strong>M</strong> for <strong>Methods</strong></a></li>
  <li><a href="#p-for-performance-measures" id="toc-p-for-performance-measures" class="nav-link" data-scroll-target="#p-for-performance-measures"><strong>P</strong> for <strong>Performance Measures</strong></a></li>
  </ul></li>
  <li><a href="#bottlenecks" id="toc-bottlenecks" class="nav-link" data-scroll-target="#bottlenecks">Bottlenecks</a></li>
  <li><a href="#evaluation" id="toc-evaluation" class="nav-link" data-scroll-target="#evaluation">Evaluation</a>
  <ul class="collapse">
  <li><a href="#key-findings" id="toc-key-findings" class="nav-link" data-scroll-target="#key-findings">Key findings</a></li>
  </ul></li>
  <li><a href="#future-research" id="toc-future-research" class="nav-link" data-scroll-target="#future-research">Future research</a></li>
  <li><a href="#my-thesis-in-numbers" id="toc-my-thesis-in-numbers" class="nav-link" data-scroll-target="#my-thesis-in-numbers">My thesis in numbers</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Cross-validation is a popular method to estimate the generalization performance of a machine learning model or algorithm. It also has its place in ML benchmarking experiments, where models or algorithms are compared based on their performance estimates. However, these estimates come with uncertainty, which is often neglected in practice. My master thesis explores different uncertainty quantification techniques for cross-validation estimates and evaluates their performance in terms of coverage and interval width. It is limited to the binary classification setting and focuses on the impact of sample size and machine learning algorithm choice on the performance of these techniques.</p>
<p>I was extremely lucky to write this thesis with supervision of Dr.&nbsp;Max Westphal at <a href="https://www.mevis.fraunhofer.de/">Fraunhofer MEVIS</a>, Bremen, and Prof.&nbsp;Dr.&nbsp;Beate Rhein from <a href="https://www.th-koeln.de/">TH Köln</a>. I totally enjoyed the process of developing this structure and writing this fairly mathematical thesis. Never have I thought I would choose such a topic when I failed 2 out of 3 math exams in my undergraduate studies. But here we are, and I am proud of the results. I hope you enjoy this write-up as much as I enjoyed writing the thesis. <!-- ![](images/image.png){width="400px"} --></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>You have estimated you model performance using cross-validation (CV). So CV tells you something like “Your model accuracy is 85%”. Great job! But what does this number actually mean? Can we expect to see 85% accuracy on unseen data every time or does the model’s performance vary on new data? And how much does it vary? These are important questions that are often neglected in practice. Depending on the domain, it is extremly important, to know your model’s limits <span class="citation" data-cites="volovici_steps_2022">(<a href="#ref-volovici_steps_2022" role="doc-biblioref">Volovici et al. 2022</a>)</span>. Think of medical applications, where a false negative can have severe consequences. But also in other domains, where it’s not about life and death, it is important to know the limits of your model. A model that predicts stock prices with an accuracy of 85% is not very useful if the uncertainty in this estimate is too large. Then the (unknown) real accuracy could be much lower (or higher), and you would not know it. A way to notate uncertainty is to construct confidence intervals (CIs) for the performance estimate. CIs have a frequentist interpretation. If we repeat the experiment including the CI construction many times, we would find the true performance to fall in the CI in 95% of the cases (when we set our nominal level to 95%). In my thesis I have performed experiments really often to explore the coverage probability of methods that yield CIs. The methods were selected by passing the following criteria:</p>
<ul>
<li>compatible with binary classification,</li>
<li>no additional model fits necessary,</li>
<li>no alterations of the CV procedure.</li>
</ul>
<p>As a side quest, I learned how to deal with over 200M CV validation predictions!</p>
<section id="research-questions" class="level3">
<h3 class="anchored" data-anchor-id="research-questions">Research Questions</h3>
<p>The following research questions guided me through my experiments and shaped how I set up the data generating processes:</p>
<ol type="1">
<li><p>Which uncertainty quantification technique provides the most accurate coverage for CV estimates in terms of deviation from nominal coverage?</p></li>
<li><p>How does the sample size affect the coverage and interval widths of different uncertainty quantification methods, particularly for smaller sample sizes?</p></li>
<li><p>To what extent does the choice of machine learning algorithm influence the coverage performance of uncertainty quantification techniques?</p></li>
</ol>
</section>
</section>
<section id="theoretical-background" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-background">Theoretical Background</h2>
<p>First we have to make sure, that we’re talking about the same cross-validation scheme. There are variations and each of them can have stochastic implications, that do matter in this context.</p>
<section id="k-fold-cv" class="level3">
<h3 class="anchored" data-anchor-id="k-fold-cv"><span class="math inline">\(k\)</span>-fold CV</h3>
<ul>
<li><p>Every observation is used once for validation</p></li>
<li><p>Mutually exclusive partitions</p></li>
<li><p>Iteratively use one partition for validation and the rest for training</p></li>
<li><p>CV estimate is the average validation score</p></li>
</ul>
</section>
<section id="properties" class="level3">
<h3 class="anchored" data-anchor-id="properties">Properties</h3>
<p>Let’s have a look at the key properties of CV that are important for the uncertainty quantification:</p>
<ul>
<li><p>Cross-validation has an internal randomness due to the random splitting when <span class="math inline">\(k_\text{folds} &lt; n_\text{obs}\)</span>. When the number of folds equals the number of observations, we call it leave-one-out CV, and the estimate is deterministic.</p></li>
<li><p>There is an overlap of <span class="math inline">\(\frac{k-2}{k-1}\)</span> observations in 2 training sets of the cross-validation.</p></li>
<li><p>Assuming model stability <span class="citation" data-cites="shalev-shwartz_understanding_2014">(<a href="#ref-shalev-shwartz_understanding_2014" role="doc-biblioref">Shalev-Shwartz and Ben-David 2014</a>)</span>, i.e.&nbsp;when a slight change of the training data does not change the model’s performance significantly, the validation scores obtained from the model are not i.i.d <span class="citation" data-cites="bengio_no_2004 markatou_analysis_2005 bates_cross-validation_2023">(<a href="#ref-bengio_no_2004" role="doc-biblioref">Bengio and Grandvalet 2004</a>; <a href="#ref-markatou_analysis_2005" role="doc-biblioref">Markatou et al. 2005</a>; <a href="#ref-bates_cross-validation_2023" role="doc-biblioref">Bates, Hastie, and Tibshirani 2023</a>)</span>.</p></li>
<li><p>No unbiased estimator for the variance of the CV estimate <span class="citation" data-cites="bengio_no_2004">(<a href="#ref-bengio_no_2004" role="doc-biblioref">Bengio and Grandvalet 2004</a>)</span>.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/cv_covariance_matrix-1.jpg" class="img-fluid figure-img"></p>
<figcaption>Covariance matrix of k-fold CV as in <span class="citation" data-cites="bengio_no_2004">(<a href="#ref-bengio_no_2004" role="doc-biblioref">Bengio and Grandvalet 2004</a>)</span>.</figcaption>
</figure>
</div>
</section>
</section>
<section id="methods-ademp" class="level2">
<h2 class="anchored" data-anchor-id="methods-ademp">Methods: ADEMP</h2>
<section id="what-are-we-doing" class="level3">
<h3 class="anchored" data-anchor-id="what-are-we-doing">What are we doing?</h3>
<p>In short, we will compare the operating characteristics of different uncertainty quantification techniques for cross-validation estimates. We can observe the frerquentist properties of these methods by conducting a large number of simulations. Confidence intervals claim to include the “true” performance in a certain percentage of cases. We will simply count how often this holds and compare. That’s it, that’s the whole idea. Now, there are a few hidden challenges. For example, we have to come up with an efficient idea to calculate the “true” performance. I will talk about this in this part. Software-wise, I am using the great <code>batchtools</code> package for <code>R</code> to map data sets to machine learning algorithms and further to all the candidate methods. <code>batchtools</code> is a tremendous help when it comes to parallelizing tasks with so many factors. Actually, we will perform three separate studies sequentially to handle all the parts of this work.</p>
<p>Here is an overview of the parts of the study before we dive into details: <img src="images/studyflow.jpg" class="img-fluid" alt="Studyflow of the simulation study."></p>
<p>There is a great framework that guides through simulation studies for comparing statistical methods and it’s called ADEMP <span class="citation" data-cites="morris_using_2019">(<a href="#ref-morris_using_2019" role="doc-biblioref">Morris, White, and Crowther 2019</a>)</span>. ADEMP is a framework to plan, structure and report monte carlo simulation studies. In this ADEMP study I used pseudo random data to generate a large number of data sets. ADEMP also indicates, how to evaluate the coverage of the UQ techniques.</p>
</section>
<section id="a-for-aims" class="level3">
<h3 class="anchored" data-anchor-id="a-for-aims"><strong>A</strong> for <strong>AIMS</strong></h3>
<p>The aims in this study were guided by the research questions. We want to (1) find the best overall technique, (2) understand the influence of sample size and (3) understand the influence of learning algorithms.</p>
</section>
<section id="d-for-data-generating-process" class="level3">
<h3 class="anchored" data-anchor-id="d-for-data-generating-process"><strong>D</strong> for <strong>Data Generating Process</strong></h3>
<p>Now it get’s more complex. It is important to describe how data is generated, so fellow readers can understand the intention and limitations. For my thesis I simulated a binary outcome from logistic models with std. normal covariates. In total, I used 12 different data generating processes (DGP) to cover a wide range of scenarios. Appropriate DGPs were determined by performing lots of pilot studies. Each DGP describes a distribution from which we can sample data sets. From each of the 12 DGPs I sampled data sets of sample sizes <span class="math inline">\(n_\text{obs} \in \{100, 500\}\)</span>. The number of covariates was varied. Some DGP also incorporated interaction terms to simulate non-linearities. I then used different learning algorithms inside of 5-fold cross-validation. The algorithms in use were Elastic Net (GLMNET), XGBoost and Support Vector Machine (SVM).</p>
<p>All these models have hyperparameters. When we tune these, we end up, with a distribution of performances that is skewed towards very good performances. This is why I instead sampled configurations randomly from appropriate search spaces. This way, we simulate a distribution of better or worse ML models, just as we would see in practice.</p>
</section>
<section id="e-for-estimand" class="level3">
<h3 class="anchored" data-anchor-id="e-for-estimand"><strong>E</strong> for <strong>Estimand</strong></h3>
<p>A Monte Carlo simulation study is powerful, because we can <em>know</em> targets of inference by controlling the data generating process. The <em>true</em> performance can be approximated and is referred to as estimand. In my study, performance estimands were calculated for the AUC, accuracy, sensitivity and specificity metrics. From <span class="citation" data-cites="bates_cross-validation_2023">Bates, Hastie, and Tibshirani (<a href="#ref-bates_cross-validation_2023" role="doc-biblioref">2023</a>)</span> we know, that CV estimates are often close to the <em>unconditional performance</em> depending on training sets of size <span class="math inline">\(n_\text{train}\)</span>. I will focus on that estimand in this post. <span class="citation" data-cites="bates_cross-validation_2023">Bates, Hastie, and Tibshirani (<a href="#ref-bates_cross-validation_2023" role="doc-biblioref">2023</a>)</span> is a great read and I totally recommend it to anyone interested in the topic. The paper says, that most often, the CV estimate is close to the performance of a algorithm trained on many training sets of size of the CV training folds drawn from the same population. So when we use this concept in the simulation, we either have to draw numerous data sets every time… or we can use the classifiers trained in other simulations (using the same DGP).</p>
<p>In order to approximate the study estimands, we draw a large <em>population</em> data set from each DGP. In practice, we would never have the possibility to generate such a population. This is why controlling the DGP in a simulation study is so awesome. The approximation of the unconditional performance is defined as follows: It’s the average performance of classifiers trained in the CV iterations in repeated simulations as evaluated on the population data set. Each simulation is performed with a different random seed, so the data sets are different but drawn from the same DGP.</p>
<p>As a formal definition, we can write the estimand as: <span class="math display">\[
\tilde{\psi}_{n_\text{train}}= \frac{1}{n_\text{sim}k_\text{folds}n_\text{pop}} \sum_{s=1}^{n_\text{sim}}  \sum_{k=1}^{k_\text{folds}} \sum_{i=1}^{n_\text{pop}} L(\phi_{k,s}(\mathbf{x}_{i}), y_{i})
\]</span></p>
<p>where <span class="math inline">\(L\)</span> is the loss function, <span class="math inline">\(\phi_{k,s}\)</span> is the classifier trained in the <span class="math inline">\(k\)</span>-th fold of the <span class="math inline">\(s\)</span>-th simulation and evaluated on the <span class="math inline">\(i\)</span>-th observation of the population data set. <span class="math inline">\(n_\text{sim}\)</span> is the number of simulations, <span class="math inline">\(n_\text{pop}\)</span> is the number of observations in the population data set.</p>
<p>So we average over all classifiers trained in CV iterations belonging to the same DGP + sample size + learning algorithm combination. This keeps the number of trainings, draws and evaluations manageable. The estimand is then used to evaluate the performance of the UQ techniques.</p>
</section>
<section id="m-for-methods" class="level3">
<h3 class="anchored" data-anchor-id="m-for-methods"><strong>M</strong> for <strong>Methods</strong></h3>
<section id="parametric-approaches" class="level4">
<h4 class="anchored" data-anchor-id="parametric-approaches">Parametric approaches</h4>
<ol type="1">
<li>We can construct Wald-intervals by pooling validation predictions (<code>Baseline</code>). We use the standard error of the proportion to calculate the confidence intervals. We define these Wald-intervals as our baseline method. All other methods are compared to this baseline and more complex methods should outperform the baseline.</li>
<li>Approximation of the correlation similar to <span class="citation" data-cites="bengio_no_2004">Bengio and Grandvalet (<a href="#ref-bengio_no_2004" role="doc-biblioref">2004</a>)</span> (<code>Param-CA</code>) <span class="math display">\[
\hat{\rho} = \left(\frac{n_\text{folds} - 2}{n_\text{folds} - 1}\right)^r
\]</span> <span class="math display">\[
r \in \{0.1, 0.2, 0.5, 1, 2\}
\]</span></li>
</ol>
<ul>
<li>Variants: different distributions and transformation (normal or t; logit transformation possible) <!-- 4.  Clopper-Pearson exact method for small binomial proportions --></li>
</ul>
</section>
<section id="bootstrapping-techniques" class="level4">
<h4 class="anchored" data-anchor-id="bootstrapping-techniques">Bootstrapping techniques</h4>
<ol type="1">
<li>Naïve parametric bootstrap (<code>Boot-naive</code>) is similar to Wald intervals. We simply bootstrap the pooled validation predictions and calculate the confidence intervals every time.</li>
<li>Hierarchical bootstrap (<code>Boot-hier</code>) <span class="citation" data-cites="davison_bootstrap_1997 goldstein_bootstrapping_2010">(<a href="#ref-davison_bootstrap_1997" role="doc-biblioref">Davison and Hinkley 1997</a>; <a href="#ref-goldstein_bootstrapping_2010" role="doc-biblioref">Goldstein 2010</a>)</span>
<ul>
<li>Sample with replacement from the fold indices –&gt;</li>
<li>Sample with replacement from the validation preds of the newly set of fold indices</li>
<li>Calculate CV estimate on the new set of validation preds</li>
</ul></li>
</ol>
<ul>
<li>Variants: basic, normal, studentized, percentile</li>
</ul>
</section>
<section id="glmm" class="level4">
<h4 class="anchored" data-anchor-id="glmm">GLMM</h4>
<ul>
<li>Model fold information as random effect in a generalized linear mixed model <span class="citation" data-cites="eugster_benchmark_2011">(<a href="#ref-eugster_benchmark_2011" role="doc-biblioref">Eugster 2011</a>)</span>: <span class="math display">\[
g(\mathbb{E}[Y|u_{k}])=Zu_{k}+\epsilon_{k}
\]</span></li>
</ul>
<p>where <span class="math inline">\(g(\cdot)=\ln(\frac{p}{1-p})\)</span> is a link function, <span class="math inline">\(Z\)</span> is the known random effects design matrix consisting of (validation) fold indices, <span class="math inline">\(u_k\)</span> is the unknown random effect, and <span class="math inline">\(\epsilon_k\)</span> is an unknown vector of random errors, i.e., the residuals that are not explained by the model.</p>
</section>
</section>
<section id="p-for-performance-measures" class="level3">
<h3 class="anchored" data-anchor-id="p-for-performance-measures"><strong>P</strong> for <strong>Performance Measures</strong></h3>
<p>Finally, we have to define how to measure the performance of the UQ techniques. Here are the key performance measures that we have to analyze: - Method failures (NA)</p>
<ul>
<li><p>Coverage probability</p>
<p><span class="math inline">\(\widehat{Cov} = \frac{1}{n_\text{sim}}\sum_s 1(\hat{\theta}^l_s \leq \tilde{\psi}_{n_\text{train}} \leq \hat{\theta}_s^u)\)</span></p></li>
<li><p>Interval width</p>
<p><span class="math inline">\(\hat{\omega} = \frac{1}{n_\text{sim}}\sum_s \hat{\theta}^u_s - \hat{\theta}^l_s\)</span></p></li>
<li><p>Boxplots can help identify general patterns of behaviour.</p></li>
<li><p>Monte Carlo standard error (MCSE) indicate the precision of the Monte Carlo estimates.</p>
<ul>
<li><span class="math inline">\(n_\text{sim}\)</span>=500 on <code>Param</code></li>
<li>We have to use a much smaller <span class="math inline">\(n_\text{sim}\)</span> for <code>Boot</code> and <code>GLMM</code> due to computational constraints.</li>
</ul></li>
</ul>
</section>
</section>
<section id="bottlenecks" class="level2">
<h2 class="anchored" data-anchor-id="bottlenecks">Bottlenecks</h2>
<p>As the previous part indicates, we have to deal with numerous different conditions, data sets, and models. Here are some of the bottlenecks I encountered during my thesis:</p>
<section id="time" class="level4">
<h4 class="anchored" data-anchor-id="time">Time</h4>
<ul>
<li>Tuning the DGP in early development took a lot of time. I wanted to make sure, to have meaningful data scenarios included, so I tweaked the DGPs a lot. This was necessary to ensure, that the scenarios are neither too easy nor too hard for the ML models. Lastly, this determins the distribution of estimands and therefore, the generalizability of the results.</li>
<li>Computation times of candidate methods: bootstrapping and especcially the Bayesian implementation of GLMMs are computationally expensive. I had to optimize the code a lot to make it run in a reasonable time frame. However, I could not spend as much study repetitions on these longer running methods. This shows in higher Monte Carlo standard errors for these methods. However, by pooling scenarios, we can lower the SE sufficiently.</li>
<li>As some of the methods have note been implemented officially yet, debugging of implementations took also quite some time.</li>
</ul>
</section>
<section id="memory" class="level4">
<h4 class="anchored" data-anchor-id="memory">Memory</h4>
<ul>
<li><p>The size of data sets from the machine learningare huge. Specifically, it is not possible to store all predicitons on the large population data set. This makes it necessary to apply all metrics as early as possible. Unfortunately, we can not compute metrics afterwards if desired.</p></li>
<li><p>When the ML part is done, we end up with a large data set. This is passed to the UQ part, where the candidate methods go to work. When the full study is parallelized, it’s no longer possible to load the data set into memory across all workers. Instead, we have to filter it for the relevant portion that are used in the part. This was achieved by leveraging the power of Apache Arrow and <code>parquet</code> files. They can be filtered before loading the ML data and are much faster to load than the original data set.</p></li>
<li><p>Lastly, the data with all intervals is huge. I almost entirely used <code>data.table</code> from here on. It allows super fast joins by reference. This came in handy, when I merged the UQ data set with the estimand data that was calculated before.</p></li>
</ul>
</section>
</section>
<section id="evaluation" class="level2">
<h2 class="anchored" data-anchor-id="evaluation">Evaluation</h2>
<p>While this does not show the frequentist properties, that I found, the following image luckily summarises my findings in a single case:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/image2.png" class="img-fluid figure-img"></p>
<figcaption>Example coverage.</figcaption>
</figure>
</div>
<p>We can see, that the parametric methods yield too small intervals that don’t cover the estimand in this case. The GLMM methods cover, but have a width that is simply unusably wide. The bootstrap methods are just in between, often covering just right and having a width that is acceptable. The hierarchical bootstrap methods are the best in this case. The percentile and studentized versions are en par often.</p>
<p>Let’s have a look at one of the many results tables in my thesis. This table shows results for the AUC metric. The average estimand and its standard deviation are shown in the grouping rows. The top part shows results for data sets of size 100, the bottom part of the table shows results for data sets of size 500. As you can see from the <span class="math inline">\(n_\text{sim}\)</span> column, I was able to perform a lot more Monte Carlo repetitions on the fast parametric methods as compared to bootstrap and GLMM. Note, how GLMM has at least nominal coverage but shows intervals that are extremly wide, on average. The baseline represents the naive Wald-intervals on the pooled validation predictions.</p>
<table class="table-large caption-top table" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">Method</th>
<th style="text-align: center;" data-quarto-table-cell-role="th"><span class="math inline">\(\widehat{Cov}\)</span> % (MCSE)</th>
<th style="text-align: center;" data-quarto-table-cell-role="th"><span class="math inline">\(\widehat{w}\)</span> (MCSE)</th>
<th style="text-align: right;" data-quarto-table-cell-role="th"><span class="math inline">\(n_\text{sim}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd" style="border-top: 2px solid; border-bottom: 2px solid;">
<td colspan="4">AUC (0.66 ± 0.14) - <span class="math inline">\(n_\text{obs}\)</span> = 100</td>
</tr>
<tr class="even">
<td>GLMM-UG</td>
<td style="text-align: center;">98.1 (0.13)</td>
<td style="text-align: center;">0.607 (0.0019)</td>
<td style="text-align: right;">11520</td>
</tr>
<tr class="odd">
<td>Param-CA-0.1-stud</td>
<td style="text-align: center;">94.1 (0.04)</td>
<td style="text-align: center;">0.496 (0.0003)</td>
<td style="text-align: right;">360000</td>
</tr>
<tr class="even">
<td>Boot-hier-stud</td>
<td style="text-align: center;">93.2 (0.20)</td>
<td style="text-align: center;">0.336 (0.0012)</td>
<td style="text-align: right;">16312</td>
</tr>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: center;">77.5 (0.07)</td>
<td style="text-align: center;">0.228 (0.0001)</td>
<td style="text-align: right;">360000</td>
</tr>
<tr class="even" style="border-top: 2px solid; border-bottom: 2px solid;">
<td colspan="4">AUC (0.75 ± 0.16) - <span class="math inline">\(n_\text{obs}\)</span> = 500</td>
</tr>
<tr class="odd">
<td>GLMM-UG</td>
<td style="text-align: center;">95.9 (0.19)</td>
<td style="text-align: center;">0.312 (0.0017)</td>
<td style="text-align: right;">11520</td>
</tr>
<tr class="even">
<td>Param-CA-0.1-stud</td>
<td style="text-align: center;">92.2 (0.04)</td>
<td style="text-align: center;">0.182 (0.0001)</td>
<td style="text-align: right;">360006</td>
</tr>
<tr class="odd">
<td>Boot-hier-stud</td>
<td style="text-align: center;">91.3 (0.20)</td>
<td style="text-align: center;">0.127 (0.0008)</td>
<td style="text-align: right;">19155</td>
</tr>
<tr class="even">
<td>Baseline</td>
<td style="text-align: center;">79.5 (0.07)</td>
<td style="text-align: center;">0.085 (0.0001)</td>
<td style="text-align: right;">360000</td>
</tr>
</tbody>
</table>
<p>The method ‘GLMM-UG’ seems to do a great job at closing on the nominal coverage. However, the intervals are too wide to be useful. The hierarchical bootstrap methods are the best trade-off between coverage and width. The sample size is crucial for intervals with good coverage <em>and</em> width.</p>
<p>To get a more general idea of coverage and how it is dependent on the sample size and evaluation metric, we can look at the following boxplots: <img src="images/sample_size_cov-1.jpg" class="img-fluid" alt="Boxplots sample size vs.&nbsp;coverage. Each data point corresponds to the coverage for intervals by a single method on a single DGP-model combination. Blue lines connect points of same subgroups."></p>
<p>Boxplots for sample size vs.&nbsp;width also support the finding, that a larger sample size is crucial for intervals with useable widths: <img src="images/width_sample_size-1.jpg" class="img-fluid" alt="Boxplots sample size vs.&nbsp;width. Each data point corresponds to the average width for intervals by a single method on a single DGP-model combination. Blue lines connect points of same subgroups."></p>
<p>Across all four metrics, we see improved (narrower) widths in almost all methods under test. This is congruent with what we would expect from the theory. Unfortunately, this means, that we can not always have reliable UQ for all metrics, when the sample size is too small.</p>
<section id="key-findings" class="level3">
<h3 class="anchored" data-anchor-id="key-findings">Key findings</h3>
<p>To keep this short, here are the key findings of my thesis:</p>
<ul>
<li>Baseline is not sufficient (supported by <span class="citation" data-cites="bates_cross-validation_2023">Bates, Hastie, and Tibshirani (<a href="#ref-bates_cross-validation_2023" role="doc-biblioref">2023</a>)</span>)</li>
<li>Poor coverage for sensitivity and specificity (all methods).</li>
<li>Issues in edge case where <span class="math inline">\(n_\text{obs}\)</span> = 100 and prevalence = 0.2. Here, the effective sample size in the validation folds is too low.</li>
<li>Skewness of estimand distribution is a problem (supported by <span class="citation" data-cites="reed_better_2007">Reed (<a href="#ref-reed_better_2007" role="doc-biblioref">2007</a>)</span>).</li>
<li>GLMM intervals are reliable but unusably wide.</li>
<li>Bootstrap: hierarchical shows good trade-off between coverage and width.</li>
<li>Our correlation approximation is promising but lacks consistency across the scenarios.</li>
<li>Sample size is crucial for intervals with good coverage <em>and</em> width.</li>
<li>Coverage on sensitivity and specificity are problematic.</li>
</ul>
</section>
</section>
<section id="future-research" class="level2">
<h2 class="anchored" data-anchor-id="future-research">Future research</h2>
<ul>
<li><span class="citation" data-cites="braschel_comparison_2016">Braschel et al. (<a href="#ref-braschel_comparison_2016" role="doc-biblioref">2016</a>)</span>: higher number of clusters in the data increases coverage.</li>
<li>Test hierarchical bootstrap with different number of folds.</li>
<li>Run hierarchical bootstrap with higher <span class="math inline">\(n_\text{sim}\)</span>.</li>
<li>Find hyperparameter strategy for the correlation approximation.</li>
</ul>
</section>
<section id="my-thesis-in-numbers" class="level2">
<h2 class="anchored" data-anchor-id="my-thesis-in-numbers">My thesis in numbers</h2>
<p>During the main simulation, 1440 scenarios (12 DGP <span class="math inline">\(\times\)</span> 2 sample sizes <span class="math inline">\(\times\)</span> 3 learning algorithms <span class="math inline">\(\times\)</span> 20 configurations) are repeated 500 times resulting in <span class="math inline">\(720000\)</span> ML unique jobs. In each job, the learning algorithm was trained 5 times in the CV and once on the available data set. This corresponds to <span class="math inline">\(4.32 \times 10^6\)</span> model fits. All trained models are used to predict on the population data set, resulting in <span class="math inline">\(1.728\times 10^{11}\)</span> predictions on the population data set. The table of validation predictions from CV has <span class="math inline">\(2.16\times 10^8\)</span> rows. After running the uncertainty quantification methods, the results table containing all the confidence intervals has 74 million rows. The study ran on two nodes of a high performance computing cluster. The <code>data.table</code>, <code>mlr3</code>, <code>batchtools</code>, <code>snow</code>, and <code>arrow</code> packages were used to manage the extreme computational load and the memory demands during asynchronuous parallel processing.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bates_cross-validation_2023" class="csl-entry" role="listitem">
Bates, Stephen, Trevor Hastie, and Robert Tibshirani. 2023. <span>“Cross-Validation: What Does It Estimate and How Well Does It Do It?”</span> <em>Journal of the American Statistical Association</em>, May. <a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2023.2197686">https://www.tandfonline.com/doi/full/10.1080/01621459.2023.2197686</a>.
</div>
<div id="ref-bengio_no_2004" class="csl-entry" role="listitem">
Bengio, Yoshua, and Yves Grandvalet. 2004. <span>“No Unbiased Estimator of the Variance of k-Fold Cross-Validation.”</span> <em>Journal of Machine Learning Research</em>, no. 5.
</div>
<div id="ref-braschel_comparison_2016" class="csl-entry" role="listitem">
Braschel, Melissa C, Ivana Svec, Gerarda A Darlington, and Allan Donner. 2016. <span>“A Comparison of Confidence Interval Methods for the Intraclass Correlation Coefficient in Community-Based Cluster Randomization Trials with a Binary Outcome.”</span> <em>Clinical Trials</em> 13 (2): 180–87. <a href="https://doi.org/10.1177/1740774515606377">https://doi.org/10.1177/1740774515606377</a>.
</div>
<div id="ref-davison_bootstrap_1997" class="csl-entry" role="listitem">
Davison, A. C., and D. V. Hinkley. 1997. <em>Bootstrap Methods and Their Application</em>. Cambridge Series in Statistical and Probabilistic Mathematics. Cambridge University Press.
</div>
<div id="ref-eugster_benchmark_2011" class="csl-entry" role="listitem">
Eugster, Manuel J A. 2011. <span>“Benchmark Experiments – a Tool for Analyzing Statistical Learning Algorithms.”</span> PhD thesis, München: <span>LMU</span> München. <a href="https://edoc.ub.uni-muenchen.de/12990/1/Eugster_Manuel_J_A.pdf">https://edoc.ub.uni-muenchen.de/12990/1/Eugster_Manuel_J_A.pdf</a>.
</div>
<div id="ref-goldstein_bootstrapping_2010" class="csl-entry" role="listitem">
Goldstein, Harvey. 2010. <span>“Bootstrapping in Multilevel Models.”</span> In <em>Handbook of Advanced Multilevel Analysis</em>. Routledge.
</div>
<div id="ref-markatou_analysis_2005" class="csl-entry" role="listitem">
Markatou, Marianthi, Hong Tian, Shameek Biswas, and George Hripcsak. 2005. <span>“Analysis of Variance of Cross-Validation Estimators of the Generalization Error.”</span> <em>Journal of Machine Learning Research</em> 6 (39): 1127–68. <a href="http://jmlr.org/papers/v6/markatou05a.html">http://jmlr.org/papers/v6/markatou05a.html</a>.
</div>
<div id="ref-morris_using_2019" class="csl-entry" role="listitem">
Morris, Tim P., Ian R. White, and Michael J. Crowther. 2019. <span>“Using Simulation Studies to Evaluate Statistical Methods.”</span> <em>Statistics in Medicine</em> 38 (11): 2074–2102. <a href="https://doi.org/10.1002/sim.8086">https://doi.org/10.1002/sim.8086</a>.
</div>
<div id="ref-reed_better_2007" class="csl-entry" role="listitem">
Reed, James F. III. 2007. <span>“Better Binomial Confidence Intervals.”</span> <em>Journal of Modern Applied Statistical Methods</em> 6 (May): 153–61. <a href="https://doi.org/10.56801/10.56801/v6.i.290">https://doi.org/10.56801/10.56801/v6.i.290</a>.
</div>
<div id="ref-shalev-shwartz_understanding_2014" class="csl-entry" role="listitem">
Shalev-Shwartz, Shai, and Shai Ben-David. 2014. <em>Understanding Machine Learning: From Theory to Algorithms</em>. 1st ed. Cambridge University Press. <a href="https://doi.org/10.1017/CBO9781107298019">https://doi.org/10.1017/CBO9781107298019</a>.
</div>
<div id="ref-volovici_steps_2022" class="csl-entry" role="listitem">
Volovici, Victor, Nicholas L. Syn, Ari Ercole, Joseph J. Zhao, and Nan Liu. 2022. <span>“Steps to Avoid Overuse and Misuse of Machine Learning in Clinical Research.”</span> <em>Nature Medicine</em> 28 (10): 1996–99. <a href="https://doi.org/10.1038/s41591-022-01961-6">https://doi.org/10.1038/s41591-022-01961-6</a>.
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/radlfabs\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="mailto:rosenthal.fabian@gmail.com">Contact Fabian Rosenthal</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>